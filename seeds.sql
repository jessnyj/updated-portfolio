INSERT INTO Blogs (title, content, createdAt, updatedAt)
VALUES("Big O & Efficiency", "A quick look into computer science
In simplest terms, Big O notation allows programmers to evaluate the efficiency of a block of code or an algorithm. The code’s efficiency can be measured by looking at the amount of time it takes for it to run, as well as the complexity of the type of data to be processed. Due to external factors, the runtime cannot be measured directly. However, it can be calculated by examining how fast the runtime increases relative to the input data that is being processed.
Let’s talk time complexity and space complexity. Essentially, when you write out any piece of code, there will always be two complexities to account for: time and space. Time complexity refers to the number of steps taken by an algorithm, with respect to n — the size of the input. Where space complexity determines the amount of space required for an algorithm to occur, with respect to n.
Big O notation always accounts for the worst case scenario. In this case, the worst case scenario refers to the maximum number of operations that is performed by an algorithm. The O in Big O notation stands for the order of. So if we are examining an algorithm with a time complexity of O(n), it would be referred to as an “order of” n. O(1) — Constant:
Big O(1) refers to a constant time complexity, which means that the runtime is constant with respect to the input size. Therefore, these algorithms will always take the same amount of time to be completed. Examples of constant time complexity include, accessing a single element within an array, as well as the push() and pop() methods.
O(n) — Linear:
Big O(n) refers to an algorithm in which time is directly proportional to the amount of input data. As mentioned before, Big O notation will always account for the maximum number of iterations to perform an algorithm. For example, if we used a for loop to print out the values of an array, if the array was 10 elements long, it would take n number of steps, or O(10). Another example of a function that has a linear time complexity is quick sort.
O(n²) — Quadratic:
A quadratic time complexity refers to an algorithm whose time increases at a rate that is proportional to the square of the input size. For example, an algorithm that has a nested loop would take n number of times to be executed (for each for loop). To elaborate, if both for loops had an input size of 5, it would have an n equal to 25. Other examples of algorithms with quadratic time complexities include bubble sort, insertion sort, and selection sort.
O(log n) — Logarithmic:
An algorithm with a logarithmic time complexity has a runtime that increases proportionally to the logarithm of the input. Mathematically speaking, a logarithmic function is the inverse of an exponential function. Luckily, with Big O notation, we aren’t focused on calculating the logarithm of a function, rather we are utilizing this information in order to make assumptions about the time an algorithm takes to be executed. A prime example of this time complexity is binary search.
These four time complexities can be arranged from fastest to slowest. The fastest and preferred time complexity is O(1). O(log n) comes second, O(n) is third, making O(n²) the slowest time complexity.
", "2020-01-01 10:10:10", "2020-01-01 10:10:10");
INSERT INTO Blogs (title, content, createdAt, updatedAt)
VALUES("Working with Foundation CSS Framework", "Discovering an easy to use, mobile responsive CSS framework is like hitting the lottery for any front end web developer. Some frameworks are too basic, too complex in design, or not easily customizable, so it is relieving when you find a good developing tool. After having used Foundation with my recent web design, I felt inclined to discuss some of their great features. First and foremost, this particular CSS framework stood out to me because of how professional and appealing their development tools are. Unlike some of the frameworks I have used in the past, their features are ready to use and do not need many modifications in order to make your site look very appealing. For example, if you want a quick responsive layout, you can use one of eight of their HTML templates. This allows for quick customization and site development. The templates create the initial skeleton of your site, and you can add and modify this skeleton utilizing their building blocks. This feature has an extensive library of website add-ins such as search boxes, cards, navigation bars, toggle switches, buttons and more. Within their building blocks section, another interesting feature they have are their building blocks kits. For example, if you know you need a blog or dashboard section, you can download one of their kits and this allows you to spend less time searching through their library of development tools. Because their features can be directly added to your HTML and CSS pages, you can easily design your site but still make it your own by adding your modifications.
Additionally, the foundation framework allows for a completely responsive design. With their XY grid, you can devise a mobile responsive site, and modify it as devices increase in size and complexity. To simplify, the XY grid utilizes Flexbox to allow for horizontal and vertical alignment. If you want to use your own code to build a semantic grid, you can use the CSS XY grid along with their Sass mix-ins.
Whether you need to create a website in a few days or have some time to spare, I highly recommend checking out Foundation to use as your next CSS framework. You won’t be disappointed with their mobile responsive features, and their vast array of development tools.", "2020-01-01 10:10:10", "2020-01-01 10:10:10");